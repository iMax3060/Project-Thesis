\chapter[RANDOM Page Eviction]{RANDOM Page Eviction} \label{ch:random}

\section[Purpose]{Purpose}

    The buffer manager of a DBMS needs to evict pages from buffer frames when currently not buffered pages need to be fetched from the database while there are no more free buffer frames. Every buffer manager got a page evictioner---implementing one of the many page eviction algorithms developed since the 1960s---for that purpose.

    According to Belady's classification in \cite{Belady:1966}, the RANDOM eviction algorithm is the most representative algorithm in his \textit{Class 1} of page eviction algorithms. Those \textit{Class 1} page eviction algorithms do not use any information about the usage of a buffered page but just apply a static rule for the eviction decision. According to the newer classification of Effelsberg and Härder in \cite{Effelsberg:1984}, the RANDOM eviction algorithm is the only algorithm in the class of algorithms using neither the age of a buffered page nor the references of it for the eviction decision.

    The RANDOM strategy is the simplest page eviction strategy possible resulting in a low overhead and bad hit rates.

\section[Compared Pseudorandom Number Generators]{Compared Pseudorandom Number Generators}

    The only operation performed by the RANDOM page evictioner to decide on the page to evict from the buffer pool is the generation of a pseudorandom number in the range of buffer frame indexes. The database page contained in the selected buffer frame is evicted afterwards.

    There are many different classes of pseudorandom number generators (\textbf{PRNG}). Some of them provide pseudorandom numbers of high randomness---appropriate for cryptographic applications---others take only few CPU cycles and almost no memory to generate a random number.

    Due to the enormous number of PRNG described in literature, an exhaustive comparison of PRNG for the use in RANDOM page evictioners is not possible in this context. Therefore, only a small selection of PRNG---mostly from the \textit{C++ Standard Library}\footnotemark[1] and the \textit{Boost Random Number Library}\footnotemark[2] (part of the \textit{Boost C++ Libraries}\footnotemark[3])---were selected for this evaluation.

    \footnotetext[1]{\url{https://en.cppreference.com/w/cpp}}
    \footnotetext[2]{\url{https://www.boost.org/doc/libs/release/doc/html/boost_random.html}}
    \footnotetext[3]{\url{https://www.boost.org/}}

\subsection[Linear Congruential Generator (LCG) -- 1958]{Linear Congruential Generator (LCG) -- 1958} \label{subsec:lcg}

    The \emph{linear congruential generator}---a generalization of the earlier proposed \emph{Lehmer generator}---is a family of PRNG that was independently proposed by W. E. Thomson in \cite{Thomson:1958} and by A. Rotenberg in \cite{Rotenberg:1960}.

    A LCG is defined by the following recurrence relation $X$:
    \begin{equation*}
        X_{n + 1} = \left(a \cdot X_n + c\right) \bmod m \quad n \geq 0
    \end{equation*}
    In this definition, $a \in \left(0, m\right)$ is the multiplier, $c \in \left[0, m\right)$ is the increment, $m \in \left(0, \infty\right)$ is the modulus and $X_0 \in \left[0, m\right)$ is the seed.

    The following members of the LCG family of PRNG that are not members of specializations defined in subsections were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{rand}: $a = 0x41C64E6D$, $c = 0x3039$, $m = 2^{31}$ if using \textit{GNU C Library}\footnote[4]{\url{https://www.gnu.org/software/libc/}}
        \item \textbf{rand48}: $a = 0x5DEECE66D$, $c = 0xB$, $m = 2^{48}$
        \item \textbf{Kreutzer1986}: Buffers 97 random numbers of a LCG with $a = 0x556$, $c = 0x24D69$, $m = 0xAE529$ and returns them shuffled according to an algorithm proposed by Carter Bays and S. D. Durham in \cite{Bays:1976}. This was proposed by Wolfgang Kreutzer in \cite{Kreutzer:1986}.
    \end{itemize}

\subsubsection[Lehmer Generator (MCG) -- 1949]{Lehmer Generator -- 1949} \label{subsubsec:mcg}

    The \emph{Lehmer generator} (also known as \emph{multiplicative congruential generator}) is the earliest family of PRNG of ``usable'' quality, proposed by Derrick H. Lehmer in \cite{Lehman:1951} in 1949.

    It is a specialization of the later proposed \emph{LCG} with $c = 0$.

    The following members of the MCG family of PRNG were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{MCG128}:     $a = 0x1168C7BF168D765C661FD0407A968ADD$, $m = 2^{64} - 1$, \SI{128}{\bit} state
        \item \textbf{MCG128Fast}: \textit{MCG128} with $a = 0xDA942042E4DD58B5$
        \item \textbf{RANECU}: Combination of two Lehmer generators ($a_1 = 0x9C4E$, $m_1 = 0x7FFFFFAB$, $a_2 = 0x9EF4$, $m_2 = 0x7FFFFF07$) where the output is $o_1 - o_2$ if $o_2 < o_1$ or $o_1 - o_2 + 0x7FFFFFAA$ (unsigned \SI{32}{\bit} output) else for $o_1$, $o_2$ random numbers generated by the two Lehmer generators. This was proposed by Pierre L'Ecuyer in \cite{LEcuyer:1988} and modified by F. James in \cite{James:1990}.
    \end{itemize}

\subsubsection[Park-Miller Generator -- 1988]{Park-Miller Generator -- 1988} \label{subsubsec:minstd}

    The \emph{Park-Miller generator} (now known as MINSTD) is a set of parameters for the \emph{Lehmer generator} proposed by Stephen K. Mark and Keith W. Miller in \cite{Park:1988}. After criticism by George Marsaglia and Stephen Sullivan, they proposed a changed set of parameters in \cite{Park:1993}.

    In their initial proposal, the parameters were $a = 16807$ and $m = 2^{31} - 1$. In their later proposal, they used $a = 48271$ instead.

    The following Park-Miller generators were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{MINSTD0}: $a = 0x41A7$, $m = 2^{31} - 1$
        \item \textbf{MINSTD}:  $a = 0xBC8F$, $m = 2^{31} - 1$
        \item \textbf{KnuthB}: Buffers 256 random numbers of \textit{MINSTD0} and returns them shuffled according to an algorithm proposed by Carter Bays and S. D. Durham in \cite{Bays:1976}. This was proposed by Donald E. Knuth in \cite{Knuth:1981}.
    \end{itemize}

\subsubsection[MIXMAX Generator -- 1991]{MIXMAX Generator -- 1991} \label{subsubsec:mixmax}

    The \emph{MIXMAX generator} is a \emph{matrix linear congruential generator} proposed by G. K. Savvidy and N. G. Ter-Arutyunyan-Savvidy in \cite{Savvidy:1991}.

    In contrast to a LCG, a matrix LCG uses a $N{\times}N$-matrix of multipliers $A$ instead of a multiplier $a$.
    \begin{equation*}
        a'_i = \begin{cases}
                   \left(\sum_{j = 1}^{N} A_{ij} \cdot a_j\right) \bmod m + s \cdot a_2 & \text{if } i = 3 \\
                   \left(\sum_{j = 1}^{N} A_{ij} \cdot a_j\right) \bmod m               & \text{else}
               \end{cases}
    \end{equation*}
    In this definition, $s \in \mathbb{Z}$ is a small ``magic'' integer, $m \in \left(0, \infty\right)$ is the modulus and the initial $N$-dimensional vector $a$ is the seed.

    The following members of the MIXMAX family of PRNG was compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{MixMax2.0}: $N = 17$, $s = 0$, $m = 2^{36} + 1$
    \end{itemize}

\subsubsection[Permuted Congruential Generator (PCG) -- 2014]{Permuted Congruential Generator (PCG) -- 2014} \label{subsubsec:pcg}

    The \emph{permuted congruential generator} is a modified \emph{linear congruential generator} proposed by Melissa E. O'Neill in \cite{ONeill:2014}.

    In contrast to a typical LCG, the PCG state has double the width of its output, the modulus $m$ is $m = 2^k$ for $k \in \mathbb{N}$ and the output is generated by a state-defined bit-wise rotation of the state.

    The following members of the PCG family of PRNG were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{PCG32}:           $a = 0x5851F42D4C957F2D$, $c = 0x14057B7EF767814F$, $m = 2^{31} - 1$, \SI{64}{\bit} state
        \item \textbf{PCG32Unique}:     \textit{PCG32} where $c$ is based on a memory address
        \item \textbf{PCG32Fast}:       \textit{PCG32} where $c = 0$
        \item \textbf{PCG32K2}:         2-dimensionally equidistributed version of \textit{PCG32}
        \item \textbf{PCG32K2Fast}:     2-dim. equidistributed version of \textit{PCG32Fast}
        \item \textbf{PCG32K64}:        64-dim. equidistributed version of \textit{PCG32}
        \item \textbf{PCG32K64Fast}:    64-dim. equidistributed version of \textit{PCG32Fast}
        \item \textbf{PCG32K1024}:      1024-dim. equidistributed version of \textit{PCG32}
        \item \textbf{PCG32K1024Fast}:  1024-dim. equidistributed version of \textit{PCG32Fast}
        \item \textbf{PCG32K16384}:     16384-dim. equidistributed version of \textit{PCG32}
        \item \textbf{PCG32K16384Fast}: 16384-dim. equidistributed version of \textit{PCG32Fast}
    \end{itemize}

\subsection[Lagged Fibonacci Generator (LFG) -- 1958]{Lagged Fibonacci Generator (LFG) -- 1958} \label{subsec:lfg}

    The \emph{lagged Fibonacci generator} is a family of PRNG---based on the generalization of the Fibonacci sequence---proposed (but never published) by G. J. Mitchell and D. P. Moore in 1958.

    A LFG is defined by the following recurrence relation $X$:
    \begin{equation*}
        X_n = \left(X_{n - j} + X_{n - k}\right) \mod m, n \geq j \land n \geq k
    \end{equation*}
    In this definition, $j = 24$ and $k = 55$ are the lags of the original proposal and $\left(X_0, ..., X_{\max\left(j, k\right)}\right)$ is the seed to be seeded based on e.g. another random number generator.

    The following (floating-point) members of the LFG family of PRNG that are not members of specializations defined in subsections were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{LaggedFibonacci607}: $j = 607$, $k = 273$, $m = 1$
        \item \textbf{LaggedFibonacci1279}: $j = 1279$, $k = 418$, $m = 1$
        \item \textbf{LaggedFibonacci2281}: $j = 2281$, $k = 1252$, $m = 1$
        \item \textbf{LaggedFibonacci3217}: $j = 3217$, $k = 576$, $m = 1$
        \item \textbf{LaggedFibonacci4423}: $j = 4423$, $k = 2098$, $m = 1$
        \item \textbf{LaggedFibonacci9689}: $j = 9689$, $k = 5502$, $m = 1$
        \item \textbf{LaggedFibonacci19937}: $j = 19937$, $k = 9842$, $m = 1$
        \item \textbf{LaggedFibonacci23209}: $j = 23209$, $k = 13470$, $m = 1$
        \item \textbf{LaggedFibonacci44497}: $j = 44497$, $k = 21034$, $m = 1$
        \item \textbf{RANMAR}: $X_n = \begin{cases}
                                          X_{n - 97} - X_{n - 33}     & \text{if } X_{n - 97} \geq X_{n - 33} \\
                                          X_{n - 97} - X_{n - 33} + 1 & \text{else}
                                      \end{cases} \bmod 1$ \\
                               combined with a simple arithmetic sequence as proposed by G. Marsaglia et al. in \cite{Marsaglia:1990} and modified by F. James in \cite{James:1990}
    \end{itemize}

    Many used parameters (lags) were proposed by R. P. Brent in \cite{Brent:1992}.

\subsubsection[Subtract-With-Borrow (SWB) -- 1991]{Subtract-With-Borrow (SWB) -- 1991} \label{subsubsec:swb}

    The \emph{subtract-with-borrow} generator is a modification of the \emph{lagged Fibonacci generator} proposed by George Marsaglia and Arif Zaman in \cite{Marsaglia:1991}.

    A SWB generator is defined by the following iterating function $f$:
    \begin{equation*}
        f\left(x_1, ..., x_j, c\right) = \begin{cases}
                                             \left(x_{j + 1 - k} - x_1 - c, 0\right)     & \text{if } x_{j + 1 - k} - x_1 - c \geq 0 \\
                                             \left(x_{j + 1 - k} - x_1 - c + b, 1\right) & \text{if } x_{j + 1 - k} - x_1 - c < 0
                                         \end{cases}
    \end{equation*}
    In this definition, $X_n = f\left(X_n\right)$ is the generated sequence. The lags $j$, $k$ and the base $b$ need to be chosen appropriately with $j > k$ and the initial seed vector $\left(x_1, ..., x_j, c\right)$ needs to be seeded based on e.g. another random number generator.

    The following members of the SWB family of PRNG were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{Ranlux24Base}:    $j = 24$, $k = 10$, $b = 2^{24} - 1$
        \item \textbf{Ranlux24}:        \textit{Ranlux24Base} discarding $200$ per $223$ generated numbers
        \item \textbf{Ranlux3}:         \textit{Ranlux24Base} discarding $199$ per $223$ generated numbers
        \item \textbf{Ranlux4}:         \textit{Ranlux24Base} discarding $365$ per $389$ generated numbers
        \item \textbf{Ranlux48Base}:    $j = 12$, $k = 5$, $b = 2^{48} - 1$
        \item \textbf{Ranlux48}:        \textit{Ranlux48Base} discarding $378$ per $389$ generated numbers
        \item \textbf{Ranlux64\_3}:     $j = 10$, $k = 24$, $b = 2^{48} - 1$ discarding $199$ per $223$ generated numbers
        \item \textbf{Ranlux64\_4}:     $j = 10$, $k = 24$, $b = 2^{48} - 1$ discarding $365$ per $389$ generated numbers
        \item \textbf{Ranlux3\_01}:     floating-point version of \textit{Ranlux3}
        \item \textbf{Ranlux4\_01}:     floating-point version of \textit{Ranlux4}
        \item \textbf{Ranlux64\_3\_01}: floating-point version of \textit{Ranlux64\_3}
        \item \textbf{Ranlux64\_4\_01}: floating-point version of \textit{Ranlux64\_4}
    \end{itemize}

    The \textit{Ranlux} family of SWB PRNG was proposed by M. Lüscher in \cite{Luescher:1993}.

\subsection[Linear Feedback Shift Register (LFSR) -- 1965]{Linear Feedback Shift Register (LFSR) -- 1965} \label{subsec:lfsr}

    The \emph{linear feedback shift register} PRNG is a family of PRNG proposed by Robert C. Tausworthe in \cite{Tausworthe:1965}.

    LSFR generators work on a bit sequence $a = \left\{a_k\right\}$ which is defined as follows:
    \begin{equation*}
        a_k = c_1 \cdot a_{k - 1} + c_2 \cdot a_{k - 2} + ... + c_n \cdot a_{k - n} \mod 2
    \end{equation*}
    The parameters $c_i \in \left\{0, 1\right\}$ with $1 \leq i \leq n$ are fixed and $n$ is the bit width of the state.
    Based on this state, the random number $y_k$ is generated as follows:
    \begin{equation*}
        y_k = \sum_{t = 1}^{L} 2^{-t} \cdot a_{qk + r - t}
    \end{equation*}
    Here, $L \leq n$ represents the bit width of the output random number, $q$ is the number of bit between two successive $y_k$ in $a_k$ ($q \geq L$) and $r$ is a random number in the state range $\left[0, 2^n - 1\right]$.

    In \cite{LEcuyer:1996}, Pierre L'Ecuyer proposed a specific PRNG as the combination of three LSFR generators using bitwise XOR operations. This LFSR PRNG was compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{Taus88}:
            \begin{tabular}[t]{lllll}
                $n_1 = 32$, &$c_1 = 2^{32} - 2$, &$L_1 = 32$, &$q_1 = 12$, &$r_1 = 18$ \\
                $n_2 = 32$, &$c_2 = 2^{32} - 2$, &$L_2 = 32$, &$q_2 = 4$,  &$r_2 = 27$ \\
                $n_3 = 32$, &$c_3 = 2^{32} - 2$, &$L_3 = 32$, &$q_3 = 17$, &$r_3 = 25$
            \end{tabular}
        \item \textbf{Hurd160}: LFSR with 32 \SI{5}{\bit} shift registers by W. J. Hurd in \cite{Hurd:1974}
        \item \textbf{Hurd288}: LFSR with 32 \SI{9}{\bit} shift registers by W. J. Hurd in \cite{Hurd:1974}
    \end{itemize}

\subsubsection[Mersenne Twister (MT) -- 1998]{Mersenne Twister (MT) -- 1998} \label{subsubsec:mt}

    The \emph{Mersenne Twister}---a twisted \emph{generalized feedback shift register} (GFSR) operating on a state matrix---was proposed by M. Matsumoto and T. Nishimura in \cite{Matsumoto:1998}. It is by far the most commonly used general-purpose PRNG.

    A more detailed description of the design and internals of the MT is unfortunately beyond the scope of this thesis.

    The following Mersenne Twisters---all proposed in the initial proposal of MT \cite{Matsumoto:1998}---were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{MT19937}: Mersenne prime is $2^{19937} - 1$
        \item \textbf{MT19937-64}: Mersenne prime is $2^{19937} - 1$, \SI{64}{\bit} version
        \item \textbf{MT11213B}: Mersenne prime is $2^{11213} - 1$
    \end{itemize}

\subsubsection[Xorshift -- 2003]{Xorshift -- 2003} \label{subsubsec:xorshift}

    The \emph{xorshift}---a sub-type of the \emph{linear feedback shift register} implemented purely using fast bitwise XOR and shift operations---was proposed by George Marsaglia in \cite{Marsaglia:2003}.

    The following implementation of a \SI{32}{\bit} \emph{xorshift} was given in \cite{Marsaglia:2003}:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
uint32_t xorshift32() {
    static uint32_t state = 2463534242;
    state ^= (state << 13);
    state = (state >> 17);
    return (state ^= (state << 5));
}
\end{centeredshadowboxlisting}
\end{@empty}
    \textcolor{black!75}{The initial \lstinline|state|---hard-coded in this example to 2463534242---should be randomly seeded in any real use case.}

    The following xorshift generators were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{xorshift32}: \SI{32}{\bit} xorshift
        \item \textbf{xorshift64*}: \SI{64}{\bit} xorshift with truncated output
        \item \textbf{xorwow}: \SI{128}{\bit} xorshift combined with a Weyl sequence
        \item \textbf{xorshift128+}: \SI{128}{\bit} xorshift with \SI{64}{\bit} shifts (\cite{Vigna:2017})
    \end{itemize}

\subsubsection[Well Equidistributed Long-Period Linear (WELL) -- 2006]{Well Equidistributed Long-Period Linear (WELL) -- 2006} \label{subsubsec:well}

    The \emph{well equidistributed long-period linear} generators---a family of PRNG of the form of GFSR and MT generators---was proposed by François Panneton et al. in \cite{Panneton:2006}.

    The WELL algorithm is as follows:
    \begin{algorithmic}[]
        \State $z_0 \leftarrow \left(m_p \land v_{i, r - 1}\right) \oplus \left(\widetilde{m}_p \land v_{i, r - 2}\right)$
        \State $z_1 \leftarrow T_0 \cdot v_{i, 0} \oplus T_1 \cdot v_{i, m_1}$
        \State $z_2 \leftarrow T_2 \cdot v_{i, m_2} \oplus T_3 \cdot v_{i, m_3}$
        \State $z_3 \leftarrow z_1 \oplus z_2$
        \State $z_4 \leftarrow T_4 \cdot z_0 \oplus T_5 \cdot z_1 \oplus T_6 \cdot z_2 \oplus T_7 \cdot z_3$
        \State $v_{i + 1, r - 1} \leftarrow v_{i, r - 2} \land m_p$
        \For {$j \leftarrow r - 2, 2$}
            \State $v_{i + 1, j} \leftarrow v_{i, j - 1}$
        \EndFor
        \State $v_{i + 1, 1} \leftarrow z_3$
        \State $v_{i + 1, 0} \leftarrow z_4$
        \State \textbf{return} $y_i = v_{i, 0}$
    \end{algorithmic}
    In the algorithm, $w$ is the bit-width of the random numbers output by the WELL algorithm, $r \in \left(0, \infty\right)$ and $p \in \left[0, w\right)$ are unique integers and $m_p \in \left(0, r\right)$ are bitmasks. The bit-width of the elements of the $r$-dimensional state vector $x_i$ is $w$ and the last $p$ bits of the last element of this vector are $0$. Possible values for the transformation $w{\times}w$-matrices $T_0, ..., T_7$ and further limitations to the parameters are given in \cite{Panneton:2006}.

    Shin Harase proposed a tempering method in \cite{Harase:2009} to make some WELL generators maximally equidistributed.

    The following WELL generators were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{WELL512}: $w = 32$, $r = 16$, $p = 0$, $m_1 = 13$, $m_2 = 9$, $m_3 = 5$
        \item \textbf{WELL521}: $w = 32$, $r = 17$, $p = 23$, $m_1 = 13$, $m_2 = 11$, $m_3 = 10$
        \item \textbf{WELL607}: $w = 32$, $r = 19$, $p = 1$, $m_1 = 16$, $m_2 = 15$, $m_3 = 14$
        \item \textbf{WELL800}: $w = 32$, $r = 25$, $p = 0$, $m_1 = 14$, $m_2 = 18$, $m_3 = 17$
        \item \textbf{WELL1024}: $w = 32$, $r = 32$, $p = 0$, $m_1 = 3$, $m_2 = 24$, $m_3 = 10$
        \item \textbf{WELL19937}: $w = 32$, $r = 624$, $p = 31$, $m_1 = 70$, $m_2 = 179$, $m_3 = 449$
        \item \textbf{WELL21701}: $w = 32$, $r = 679$, $p = 27$, $m_1 = 151$, $m_2 = 327$, $m_3 = 84$
        \item \textbf{WELL23209}: $w = 32$, $r = 726$, $p = 23$, $m_1 = 667$, $m_2 = 43$, $m_3 = 462$
        \item \textbf{WELL44497}: $w = 32$, $r = 1391$, $p = 15$, $m_1 = 23$, $m_2 = 481$, $m_3 = 229$
        \item \textbf{WELL800-ME}: \textit{WELL800} with $y_i \leftarrow v_{i, 0} \oplus \left(v_{i, 19} \land 0x4880\right)$
        \item \textbf{WELL19937-ME}: \textit{WELL19937} with $y_i \leftarrow v_{i, 0} \oplus \left(v_{i, 180} \land 0x4118000\right)$
        \item \textbf{WELL21701-ME}: \textit{WELL21701} with $y_i \leftarrow v_{i, 0} \oplus \left(v_{i, 328} \land 0x1002\right)$
        \item \textbf{WELL23209-ME}: \textit{WELL23209} with $y_i \leftarrow v_{i, 0} \oplus \left(v_{i, 44} \land 0x5100000\right)$
        \item \textbf{WELL44497-ME}: \textit{WELL44497} with $y_i \leftarrow v_{i, 0} \oplus \left(v_{i, 482} \land 0x48000000\right)$
    \end{itemize}

\subsubsection[Xoshiro -- 2018]{Xoshiro -- 2018} \label{subsubsec:xoshiro}

    The \emph{xoshiro}---a \emph{linear feedback shift register} generator implemented using XOR, shift and rotate operations---was---together with \emph{xoroshiro}---proposed by David Blackman and Sebastiano Vigna in \cite{Blackman:2018}.

    The following (slightly modified) implementation of a \SI{32}{\bit} \emph{xoshiro} with a \SI{128}{\bit} state was given in \cite{Blackman:2018}:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
void xoshiro128() {
    static uint32_t s0_ = 0x01d353e5f3993bb1;
    static uint32_t s1_ = 0xf7381bed96327640;
    static uint32_t s2_ = 0xfdfcaa91110765b5;
    static uint32_t s3_ = 0x0;
    const uint64_t t = s1_ << a;
    s2_ ^= s0_;
    s3_ ^= s1_;
    s1_ ^= s2_;
    s0_ ^= s3_;
    s2_ ^= t;
    s3_ = (s3_ << b) | (s3_ >> (32 - b));
}
\end{centeredshadowboxlisting}
\end{@empty}
    \textcolor{black!75}{The initial \lstinline|s0_|, \lstinline|s1_|, \lstinline|s2_| and \lstinline|s3_| which are the state---hard-coded in this example to 0x01d353e5f3993bb1, 0xf7381bed96327640, 0xfdfcaa91110765b5 and 0x0---should be randomly seeded in any real use case.} For the \SI{32}{\bit} case, the authors proposed shift and rotate values to be $\texttt{\small a} = 9$ and $\texttt{\small b} = 11$.

    It can be easily seen in the implementation, that \emph{xoshiro} does not define the generation of a pseudorandom number from its state. The authors proposed four scramblers to be used with \emph{xoshiro} (and \emph{xoroshiro}) where the two more advanced ones try to eliminate linear artifacts from the state.
    
    \begin{itemize}
        \itemsep0em
        \item[\textbf{$\mathbf{+}$ scrambler}]  The simple $\mathbf{+}$ scrambler returns just the sum of two of the state words (e.g. \lstinline|return s0_ + s3_|).
        \item[\textbf{$\mathbf{*}$ scrambler}]  The not any less simple $\mathbf{*}$ scrambler returns just the product of one of the state words with a fixed, odd multiplier (e.g. \lstinline|return s1_ + mult|).
        \item[\textbf{$\mathbf{++}$ scrambler}] The $\mathbf{++}$ scrambler first adds up two of the state words, rotates the sum to the left by \lstinline|r| positions and returns the sum of this rotated sum and the first of the two state words used in the first sum (e.g. \lstinline{return ((s0_+s3_) << r) | ((s0_+s3_) >> (32-r)) + s0_}). The authors propose \lstinline|r = 7| in the \SI{32}{\bit} case.
        \item[\textbf{$\mathbf{**}$ scrambler}] The $\mathbf{**}$ scrambler first multiplies one of the state words with a fixed, odd multiplier \lstinline|s|, rotates the product to the left by \lstinline|r| positions and returns the product of this rotated product and another fixed, odd multiplier \lstinline|t| (e.g. \lstinline{return ((s1_*s) << r) | ((s1_*s) >> (32-r)) * t}). The authors propose \lstinline|s = 5|, \lstinline|r = 7| and \lstinline|t = 9| in the \SI{32}{\bit} case.
    \end{itemize}

    The following xoshiro generators were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{xoshiro128$\mathbf{+}$32}: \SI{32}{\bit} \emph{xoshiro} with \SI{128}{\bit} state and $\mathbf{+}$ scrambler
        \item \textbf{xoshiro128$\mathbf{**}$32}: \SI{32}{\bit} \emph{xoshiro} with \SI{128}{\bit} state and $\mathbf{**}$ scrambler
    \end{itemize}

\subsubsection[Xoroshiro -- 2018]{Xoroshiro -- 2018} \label{subsubsec:xoroshiro}

    The \emph{xoroshiro}---another \emph{linear feedback shift register} generator implemented using XOR, shift and rotate operations---was proposed by David Blackman and Sebastiano Vigna in \cite{Blackman:2018}.

    The following (slightly modified) implementation of a \SI{64}{\bit} \emph{xoroshiro} with a \SI{128}{\bit} state was given in \cite{Blackman:2018}:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
void xoroshiro128() {
    static uint64_t s0_ = 0xc1f651c67c62c6e0;
    static uint64_t s1_ = 0x30d89576f866ac9f;
    const uint64_t t = s0_ ^ s1_;
    s0_ = ((s0_ << a) | (s0_ >> (64 - a)))
        ^ t ^ (t << b);
    s1_ = (t << c) | (t >> (64 - c));
}
\end{centeredshadowboxlisting}
\end{@empty}
    \textcolor{black!75}{The initial \lstinline|s0_| and \lstinline|s1_| which are the state---hard-coded in this example to 0xc1f651c67c62c6e0 and 0x30d89576f866ac9f---should be randomly seeded in any real use case.} For the \SI{64}{\bit} case, the authors proposed shift and rotate values to be $\texttt{\small a} = 24$, $\texttt{\small b} = 16$ and $\texttt{\small c} = 37$.

    For the generation of pseudorandom numbers from the states of a \emph{xoroshiro} generator, the scramblers $\mathbf{+}$, $\mathbf{*}$, $\mathbf{++}$ and $\mathbf{**}$, that are also used for \emph{xoshiro}, are used. The details of these scramblers are described in Subsection \ref{subsubsec:xoshiro}.

    The following xoroshiro generators were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{xoroshiro128$\mathbf{+}$32}: \SI{64}{\bit} \emph{xoroshiro} with \SI{128}{\bit} state and $\mathbf{+}$ scrambler
        \item \textbf{xoroshiro64$\mathbf{+}$32}:  \SI{32}{\bit} \emph{xoroshiro} with \SI{64}{\bit} state and $\mathbf{+}$ scrambler
        \item \textbf{xoroshiro64$\mathbf{*}$32}:  \SI{32}{\bit} \emph{xoroshiro} with \SI{64}{\bit} state and $\mathbf{*}$ scrambler
        \item \textbf{xoroshiro64$\mathbf{**}$32}: \SI{32}{\bit} \emph{xoroshiro} with \SI{64}{\bit} state and $\mathbf{**}$ scrambler
    \end{itemize}

\subsection[Inversive Congruential Generator (ICG) -- 1986]{Inversive Congruential Generator (ICG) -- 1986} \label{subsec:icg}

    The \emph{inversive congruential generator} is a family of PRNG proposed by Jürgen Eichenauer and Jürgen Lehn in \cite{Eichenauer:1986}.

    A ICG is defined by the following recurrence relation $X$:
    \begin{equation*}
        X_{n + 1} = \begin{cases}
                        \left(a \cdot X_n^{-1} + b\right) \bmod p & \text{if } X_n \geq 1 \\
                        b                                         & \text{else}
                    \end{cases}
    \end{equation*}
    In this definition, $a \in \mathbb{N}$ is the multiplier, $b \in \mathbb{N}$ is the increment, $p$ is the prime modulus and $X_0 \in \left[0, p\right)$ is the seed. $X_n^{-1}$ is the multiplicative inverse of $X_n$ in the finite field $GF\left(p\right)$.

    The following member of the ICG family of PRNG was compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{Hellekalek1995}: $a = 0x238E$, $b = 0x7DCD313A$, $p = 0x7FFFFFFF$ as proposed by Peter Hellekalek in \cite{Hellekalek:1995}
    \end{itemize}

\subsection[Ranshi -- 1995]{ranshi -- 1995} \label{subsec:ranshi}

    The \emph{ranshi} algorithm is a PRNG proposed by F. Gutbrod in \cite{Gutbrod:1995}.

    The idea behind the algorithm is a physical system made of a number of black balls each with a position and a spin (state of the PRNG). A red ball---having also a spin and a position---colliding with the black balls is used to generate pseudorandom numbers.

\subsection[Gjrand -- 2005]{Gjrand -- 2005} \label{subsec:gjrand}

    The \emph{gjrand} algorithm is based on a random invertible mapping\footnote[5]{\url{http://www.pcg-random.org/posts/random-invertible-mapping-statistics.html}} of addition, XOR and rotate operations. This family of PRNG was proposed by David Blackman\footnote[6]{\url{http://gjrand.sourceforge.net/}}.

    The following member of the gjrand family of PRNG was compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{gjrand32}: \SI{32}{\bit} PRNG with \SI{128}{\bit} state, parameters from the author
    \end{itemize}

\subsection[A Small Noncryptographic PRNG (JSF) -- 2007]{A Small Noncryptographic PRNG (JSF) -- 2007} \label{subsec:jsf}

    The \emph{JSF} algorithm is based on a reversible, nonlinear function where all internal state bits affect one another of addition, XOR, rotate and conditional branch operations. This family of PRNG was proposed by Bob Jenkins\footnote[7]{\url{http://burtleburtle.net/bob/rand/smallprng.html}}.

    The following implementation (with \lstinline|b_ = c_ = d_| properly seeded) of a \SI{32}{\bit} \emph{JSF} was used:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
uint32_t jsf32() {
    static uint32_t a_ = 0xf1ea5eed;
    static uint32_t b_ = 0xcafe5eed00000001;
    static uint32_t c_ = 0xcafe5eed00000001;
    static uint32_t d_ = 0xcafe5eed00000001;
    uint32_t e = a_ - ((b_ << p)
                     | (b_ >> (32 - p)));
    a_ = b_ ^ ((c_ << q) | (c_ >> (32 - q)));
    b_ = c_ + (r ? ((d_ << r)
                  | (d_ >> (32 - r))) : d_);
    c_ = d_ + e;
    d_ = e + a_;
    return d_;
}
\end{centeredshadowboxlisting}
\end{@empty}

    The following members of the JSF family of PRNG were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{JSF32n}: \lstinline|p = 27|, \lstinline|q = 17|, \lstinline|r = 0|
        \item \textbf{JSF32r}: \lstinline|p = 23|, \lstinline|q = 16|, \lstinline|r = 11|
    \end{itemize}

\subsection[SFC -- 2010]{SFC -- 2010} \label{subsec:sfc}

    The \emph{SFC} algorithm is based on a random invertible mapping\footnotemark[5] of addition, XOR, shift and rotate operations. This family of PRNG was proposed by Chris Doty-Humphrey as part of his PractRand\footnote[8]{\url{http://pracrand.sourceforge.net/}} statistical test and PRNG library.

    The following implementation (with \lstinline|a_|, \lstinline|b_| and \lstinline|c_| properly seeded) of a \SI{32}{\bit} \emph{SFC} was used:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
uint32_t sfc32() {
    static uint32_t a_ = 0xcafef00dbeef5eed;
    static uint32_t b_ = 0xcafef00dbeef5eed;
    static uint32_t c_ = 0xcafef00dbeef5eed;
    static uint32_t d_ = 0x1;
    uint32_t t = a_ + b_ + d_++;
    a_ = b_ ^ (b_ >> q);
    b_ = c_ + (c_ << r);
    c_ = (c_ << p) | (c_ >> (64 - p)) + t;
    return t;
}
\end{centeredshadowboxlisting}
\end{@empty}

    The following member of the SFC family of PRNG was compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{SFC32}: \lstinline|p = 21|, \lstinline|q = 9|, \lstinline|r = 3|
    \end{itemize}

\subsection[Counter-Based Random Number Generator (CBRNG) -- 2011]{Counter-Based Random Number Generator (CBRNG) -- 2011} \label{subsec:cbrng}

    The \emph{counter-based random number generator} is a family of PRNG proposed by J. Salmon et al. in \cite{Salmon:2011}.

    The state of a CBRNG is a simple integer counter but the output mapping is done using a complex function---usually a cryptographic block cipher.

\subsubsection[ARC4 -- 1997]{ARC4 -- 1997} \label{subsubsec:arc4}

    The \emph{ARC4} is a PRNG first implemented in OpenBSD 2.1\footnote[9]{\url{https://man.openbsd.org/arc4random}} in 1997 for function \lstinline|arc4random|.

    It generates pseudorandom numbers from the keystream of the RC4 stream cipher which was released by Ronald L. Rivest in 1987. \emph{ARC4} is not exactly a \emph{CBRNG} because it uses a second state which is not a counter but the PRNG is closely related to the other \emph{CBRNG} as it uses just a stream cipher to generate pseudorandom numbers.

\subsubsection[ChaCha -- 2008]{ChaCha -- 2008} \label{subsubsec:chacha}

    \emph{ChaCha} is a stream cipher proposed by Daniel J. Bernstein in \cite{Bernstein:2008}. It is used as a PRNG by encoding the state of the PRNG---a simple integer counter---using the \emph{ChaCha} stream cipher.

    The following PRNG based on the family of ChaCha stream ciphers were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{ChaCha4}: Based on ChaCha 4-round cipher
        \item \textbf{ChaCha5}: Based on ChaCha 5-round cipher
        \item \textbf{ChaCha6}: Based on ChaCha 6-round cipher
        \item \textbf{ChaCha8}: Based on ChaCha 8-round cipher
        \item \textbf{ChaCha20}: Based on ChaCha 20-round cipher
    \end{itemize}

\subsubsection[Advanced Randomization System (ARS) -- 2011]{Advanced Randomization System (ARS) -- 2011} \label{subsubsec:ars}

    The \emph{advanced randomization system} is a \emph{counter-based random number generator} where the state---a simple integer counter---is mapped to the random output using a simplified AES block cipher.

    The following ARS generator was compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{ARS4x32}: 7 rounds, operating on four \SI{32}{\bit} integers
    \end{itemize}

\subsubsection[Threefry -- 2011]{Threefry -- 2011} \label{subsubsec:threefry}

    The \emph{Threefry} is a \emph{counter-based random number generator} where the state is mapped to the random output using a simplified Threefish block cipher.

    The following Threefry generators were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{Threefry2x32}: 20 rounds, operating on two  \SI{32}{\bit} integers
        \item \textbf{Threefry4x32}: 20 rounds, operating on four \SI{32}{\bit} integers
        \item \textbf{Threefry2x64}: 20 rounds, operating on two  \SI{64}{\bit} integers
        \item \textbf{Threefry4x64}: 20 rounds, operating on four \SI{64}{\bit} integers
    \end{itemize}

\subsubsection[Philox -- 2011]{Philox -- 2011} \label{subsubsec:philox}

    The \emph{Philox} is a \emph{counter-based random number generator} where the state is mapped to the random output using a modified and simplified Threefish block cipher.

    The following Threefry generators were compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{Philox2x32}: 10 rounds, operating on two  \SI{32}{\bit} integers
        \item \textbf{Philox4x32}: 10 rounds, operating on four \SI{32}{\bit} integers
        \item \textbf{Philox2x64}: 10 rounds, operating on two  \SI{64}{\bit} integers
        \item \textbf{Philox4x64}: 10 rounds, operating on four \SI{64}{\bit} integers
    \end{itemize}

\subsubsection[Advanced Encryption Standard (AES) -- 2011]{Advanced Encryption Standard (AES) -- 2011} \label{subsubsec:aes}

    The \emph{Advanced Encryption Standard} PRNG is a \emph{counter-based random number generator} where the state is mapped to the random output using the AES block cipher.

    The following AES generator was compared:
    \begin{itemize}
		\itemsep0em
        \item \textbf{AES4x32}: 10 rounds, operating on four \SI{32}{\bit} integers
    \end{itemize}

\subsection[SplitMix -- 2014]{SplitMix -- 2014} \label{subsec:splitmix}

    \emph{SplitMix} is a PRNG similar to the \emph{CBRNG}s that was proposed by Guy Steele et al. in \cite{Steele:2014}. It is derived from the PRNG \emph{DotMix} which was proposed by Charles Leiserson et al. in \cite{Leiserson:2012}.

    While the state of \emph{CBRNG}s is advanced by adding $1$---it is a simple counter---the state of \emph{SplitMix} is advanced by adding a fixed $\gamma$. Instead of using a complex hash function for the generation of a pseudorandom integer from the state, \emph{SplitMix} uses the finalization mix of the MurmurHash3\footnote[10]{\url{https://bit.ly/2tI7IqW}} hash function. This is sufficient as long as $\gamma$ is not a simple value like $1$, even or some other problematic value.

    The following implementation (with \lstinline|state| and \lstinline|gamma| properly seeded) of \SI{32}{\bit} \emph{SplitMix} was used:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
uint32_t splitmix32() {
    static uint64_t state = 0xbad0ff1ced15ea5e;
    static uint64_t gamma = 0x9e3779b97f4a7c15
                          | 1;
    uint64_t seed = state;
    state += gamma;
    seed ^= seed >> v;
    seed *= m5;
    seed ^= seed >> w;
    seed *= m6;
    return result_type(seed >> 32);
}
\end{centeredshadowboxlisting}
\end{@empty}
    The \lstinline{| 1} after the seed of \lstinline|gamma| takes care of even \lstinline|gamma|s which would degrade the quality of the pseudorandom numbers generated.

    The \emph{SplitMix} PRNG used for the evaluation---\textbf{SplitMix32}---uses the following parameters: \lstinline|m5 = 0x62a9d9ed799705f5|, \lstinline|m6 = 0xcb24d0a5c88c35b3|, \lstinline|v = 33| and \lstinline|w = 28|.

\subsection[Combinations of different PRNG]{Combinations of different PRNG} \label{subsec:combination}

    The following combined PRNG were compared:
    \begin{itemize}
        \itemsep0em
        \item \textbf{DualRand}: LCG with $a = 0x10405$, $c = 0x3035$, $m = 2^{32} - 1$ XORed with a LFSR approximated by $X_n = X_{n - 1 \bmod 64} \oplus X_{n - 33 \bmod 64} \bmod 2$ on a \SI{128}{\bit} state
        \item \textbf{TripleRand}: \textit{DualRand} XORed with \textit{Hurd288}
    \end{itemize}

\subsection[Biased Uniform Int Distribution]{Biased Uniform Integer Distribution} \label{subsec:distribution}

    The PRNGs listed above return pseudorandom integers in the range of $0$ to $2^{32} - 1$ or some other arbitrary range. But for the use in a RANDOM page eviction algorithm, the numbers need to be in the range of the buffer frame indexes.

    This requires an algorithm that transforms pseudorandom numbers uniformly distributed in a given range to pseudorandom numbers in the wanted range, keeping the uniform distribution. A blog post\footnote[11]{\url{http://www.pcg-random.org/posts/bounded-rands.html}} by Melissa E. O'Neill revealed, that this transformation is the bottleneck of fast random number generation when the \lstinline|std::uniform_int_distribution| from the \textit{C++ Standard Library} is used.

    Therefore, the algorithm that turned out to be the fastest in her comparison was used in the evaluation of PRNGs for RANDOM page evictioners. In contrast to the algorithm built into the \textit{C++ Standard Library}, this one returns pseudorandom numbers in a biased uniform distribution when the range of the used PRNG is not a multiple of the range of the buffer frame indexes. For example, if the PRNG returns numbers uniformly distributed in the integer interval $\left[1 .. 6\right]$ and if the buffer frame indexes are in the interval $\left[1 .. 4\right]$, this algorithm returns $1$ and $2$ with a probability of $\sfrac{1}{3}$ and $3$ and $4$ with a probability of $\sfrac{1}{6}$. But as long as the range of buffer frame indexes is much smaller than the range of the used PRNG, the bias is less severe.

    For a PRNG returning random numbers in the range of $0$ to $2^{32} - 1$, the algorithm is as follows:
\begin{@empty}
    \lstset{
        language = [ISO]C++
    }
\begin{centeredshadowboxlisting}
uint32_t biased_int_dist(uint32_t ranNum,
                         uint32_t rangeMin,
                         uint32_t rangeMax) {
    uint64_t r = uint64_t(rangeMax - rangeMin);
    uint64_t m = uint64_t(ranNum) * (r + 1);
    return uint32_t(rangeMin + (m >> 32);
}
\end{centeredshadowboxlisting}
\end{@empty}
    The actual implementation used---available on GitHub\footnote[12]{\url{https://bit.ly/37RQQNx}}---works with PRNGs returning integers in any range as well as floating point numbers. It uses metaprogramming to utilize compile-time calculation wherever possible.

\section[Performance Evaluation]{Performance Evaluation} \label{sec:random-performance}

    Benchmarks of an exemplary DBMS using all the compared RANDOM page evictioners revealed, that there is no statistically significant difference in the hit rates achieved with these different RANDOM page evictioners. Therefore, the only performance difference between the different RANDOM page evictioners is the overhead imposed by the generation of pseudorandom numbers. For this reason, a microbenchmark measuring only the execution time of the PRNGs is appropriate.

    The only variable of the evaluation is the PRNG used---the alternatives presented in the previous section are evaluated.

    Another potential variable is the number of threats generating pseudorandom numbers. But the behavior of the PRNGs when used concurrently is usually not specified and therefore, all the PRNGs would require synchronization when used by multiple evicting threads. But due to the fact, that the quality of the pseudorandom numbers generated does not matter here, it is assumed, that each evicting thread uses its own thread-local instance of the used PRNG to choose candidates for eviction. And those thread-local instances scale perfectly as long as there are hardware threads available and therefore, an evaluation on one thread is sufficient.

    Different algorithms to generate the pseudorandom integers uniformly distributed in a given range could also be compared. But a quick comparison of the custom algorithm presented in Subsection \ref{subsec:distribution} with the ones provided by the \textit{C++ Standard Library}\footnote[13]{\url{https://bit.ly/39Xuiwn}} and by the \textit{Boost Random Number Library}\footnote[14]{\url{https://bit.ly/37JKHTs}} showed, that the used one\footnote[15]{The classic modulo algorithm was used for \textbf{rand}, \textbf{xorwow} and \textbf{xorshift128+}.} is never slower than the competition.

    The smallest ($>0$) and largest integers returned by the PRNGs---re\-pre\-sen\-ting the smallest and largest buffer pool indexes---do not significantly influence the performance of the RANDOM page evictioners. Therefore, this integer interval $\left[1 .. 53467\right]$ is a constant in this evaluation.

\begin{@empty}
    \nottoggle{bwmode}{
        \tikzset{%
            bar/.style = {draw = blue, fill = blue!25}
        }
    }{
        \tikzset{%
            bar/.style = {draw = black, fill = black!25}
        }
    }

    \begin{figure}[p]
        \centering
        \resizebox{\textwidth}{!}{
            \begin{tikzpicture}[]
                \begin{axis}[xbar,
                             xmin = 0,
                             width = 1.25\textwidth,
                             height = 1.325\textheight,
                             enlarge y limits = 0.025,
                             xlabel = {$\text{Average index generations }\left[\si{\indexes\per\second}\right]$},
                             xmin = 0,
                             xmax = 1290000000,
                             symbolic y coords = {MT11213B, MT19937-64, MT19937, Hurd288, Hurd160, Taus88, Ranlux64\_4\_01, Ranlux64\_3\_01, Ranlux4\_01, Ranlux3\_01, Ranlux64\_4, Ranlux64\_3, Ranlux48, Ranlux48Base, Ranlux4, Ranlux3, Ranlux24, Ranlux24Base, RANMAR, LaggedFibonacci44497, LaggedFibonacci23209, LaggedFibonacci19937, LaggedFibonacci9689, LaggedFibonacci4423, LaggedFibonacci3217, LaggedFibonacci2281, LaggedFibonacci1279, LaggedFibonacci607, PCG32K16384Fast, PCG32K16384, PCG32K1024Fast, PCG32K1024, PCG32K64Fast, PCG32K64, PCG32K2Fast, PCG32K2, PCG32Fast, PCG32Unique, PCG32, MixMax2.0, KnuthB, MINSTD, MINSTD0, RANECU, MCG128Fast, MCG128, Kreutzer1986, rand48, rand},
                             ytick = data,
                             nodes near coords,
                             nodes near coords align = {horizontal}]
                    \addplot[bar] table[x = throughput, y = prng] {./data/random/throughput_top.csv};
                \end{axis}
            \end{tikzpicture}
        }
        \caption{The index generation throughput of the evaluated RANDOM implementations (1 of 2)}
        \label{fig:random_performance_top}
    \end{figure}

    \begin{figure}[p]
        \centering
        \resizebox{\textwidth}{!}{
            \begin{tikzpicture}[]
                \begin{axis}[xbar,
                             xmin = 0,
                             width = 1.25\textwidth,
                             height = 1.325\textheight,
                             enlarge y limits = 0.025,
                             xlabel = {$\text{Average index generations }\left[\si{\indexes\per\second}\right]$},
                             xmin = 0,
                             xmax = 1290000000,
                             symbolic y coords = {TripleRand, DualRand, SplitMix32, AES4x32, Philox4x64, Philox2x64, Philox4x32, Philox2x32, Threefry4x64, Threefry2x64, Threefry4x32, Threefry2x32, ARS4x32, ChaCha20, ChaCha8, ChaCha6, ChaCha5, ChaCha4, ARC4, SFC32, JSF32r, JSF32n, gjrand32, ranshi, Hellekalek1995, Xoroshiro64**32, Xoroshiro64*32, Xoroshiro64+32, Xoroshiro128+32, Xoshiro128**32, Xoshiro128+32, WELL44497-ME, WELL23209-ME, WELL21701-ME, WELL19937-ME, WELL800-ME, WELL44497, WELL23209, WELL21701, WELL19937, WELL1024, WELL800, WELL607, WELL521, WELL512, xorshift128+, xorwow, xorshift64*, xorshift32},
                             ytick = data,
                             nodes near coords,
                             nodes near coords align = {horizontal}]
                    \addplot[bar] table[x = throughput, y = prng] {./data/random/throughput_bottom.csv};
                \end{axis}
            \end{tikzpicture}
        }
        \caption{The index generation throughput of the evaluated RANDOM implementations (2 of 2)}
        \label{fig:random_performance_bottom}
    \end{figure}
\end{@empty}

\subsection[Microbenchmark]{Microbenchmark}

    The microbenchmark used for the performance evaluation of the RANDOM page eviction algorithms instantiates the evaluated PRNG with a seed---generated using \lstinline|std::random_device|\footnote[16]{\url{https://bit.ly/306x2TE}}---, calculates a given number (\num{5000000}) of pseudorandom integers in the interval $\left[1 .. 53467\right]$ using the PRNG and measures the wall time elapsed.

\subsection[System Configuration]{Configuration of the Used System}

\begin{@empty}
    \begin{itemize}
        \itemsep0em
		\item	\textbf{CPU:} \emph{Intel® Core™ i7-8700} @$12 \times \SI{3.2}{\giga\hertz}$ from late 2017
        \item	\textbf{Main Memory:} $2 \times 8\text{GB} = 16\text{GB}$ of DDR4-SDRAM @\SI{2666}{\mega\hertz}
        \item	\textbf{OS:} \emph{Ubuntu 19.10}
    \end{itemize}
\end{@empty}

\subsection[Benchmark Results]{Benchmark Results}

    Figures \ref{fig:random_performance_top} and \ref{fig:random_performance_bottom} show the index generation throughput of the evaluated RANDOM page eviction implementations.

    The \emph{ICG} \textbf{Hellekalek1995} and the \emph{SWB}s of the \textbf{Ranlux} family (not the non-discarding ``base'' ones) are the slowest PRNGs in the evaluation. The XOR-based \emph{LSFR} PRNGs and the \emph{LCG}s of the \textbf{PCG} and \textbf{MCG} families are among the fastest PRNGs. The very recent \textbf{SplitMix32} PRNG described in Subsection \ref{subsec:splitmix} is by far the fastest algorithm in the competition with an average of \SI{1124474870
    }{\indexes\per\second} on the used system.

\section{Conclusion}

    Like any other DBMS component evaluated for this thesis, the performance (the overhead of the eviction candidate selection, not the achieved hit rate) of the RANDOM eviction algorithm is not critical in most cases. But the hit rate achieved with the chosen page eviction strategy is a major performance factor of a database system.

    When it comes to the selection of a page eviction strategy, the RANDOM eviction strategy is the worst but simplest option. The simplicity makes the RANDOM page eviction strategy a valid choice when it is expected that the main memory is (almost) always large enough to contain the complete working set of a DBS. In this case, the RANDOM eviction strategy would not perform (much) worse than any other ``good'' page eviction strategy.

    When the RANDOM page eviction strategy is chosen for the use in a buffer pool manager of a DBMS, there is basically no reason not to use the fastest PRNG available in the particular programming language. The fastest PRNG in this comparison---\emph{SplitMix}---is part of the Java Development Kit and good implementations are also available in Haskell and C++. The slightly slower XOR-based \emph{LSFR} PRNGs are available for many programming languages and the mid-range PRNG \textbf{MT19937} is the default PRNG for most of the programming languages. Most of the fast general-purpose PRNGs can be easily implemented in any programming language typically used in the development of a DBMS and therefore, the lack of such a PRNG in a particular programming language can quickly be compensated.
